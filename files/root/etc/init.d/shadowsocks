#!/bin/sh /etc/rc.common
#
# Copyright (C) 2014-2017 Jian Chang <aa65535@live.com>
#
# This is free software, licensed under the GNU General Public License v3.
# See /LICENSE for more information.
#

START=90
STOP=15

NAME=shadowsocks
EXTRA_COMMANDS="rules watchdog"
CRON_FILE=/etc/crontabs/root

uci_get_by_name() {
	local ret=$(uci get $NAME.$1.$2 2>/dev/null)
	echo ${ret:=$3}
}

uci_get_by_type() {
	local ret=$(uci get $NAME.@$1[0].$2 2>/dev/null)
	echo ${ret:=$3}
}

uci_bool_by_name() {
	case "$(uci_get_by_name $1 $2)" in
		1|on|true|yes|enabled) return 0;;
	esac
	return 1
}

validate_server() {
	[ "$(uci get $NAME.$1 2>/dev/null)" = "servers" ]
}

has_valid_server() {
	for server in $@; do
		validate_server $server && return 0
	done
	return 1
}

get_arg_udp() {
	local server=$(uci_get_by_type transparent_proxy udp_relay_server)
	[ "$server" = "same" ] || validate_server $server && echo "-u"
}

get_arg_out() {
	case "$(uci_get_by_type access_control self_proxy 1)" in
		1) echo "-o";;
		2) echo "-O";;
	esac
}

get_arg_tfo() {
	if [ "3" = "$(cat /proc/sys/net/ipv4/tcp_fastopen 2>/dev/null)" ]; then
		uci_bool_by_name $1 fast_open && echo "--fast-open"
	fi
}

get_server_ips() {
	echo $(uci_get_by_name $1 server)
}

get_lan_hosts() {
	uci_bool_by_name $1 enable && \
		echo "$(uci_get_by_name $1 type),$(uci_get_by_name $1 host)"
}

get_plugin_config() {
	local plugin=$(uci_get_by_name $1 plugin)
	local plugin_opts=$(uci_get_by_name $1 plugin_opts)
	if [ -n "$plugin" -a -n "$plugin_opts" ]; then
		echo $plugin >>/var/run/ss-plugin
		echo "
    \"plugin\": \"$plugin\",
    \"plugin_opts\": \"$plugin_opts\","
	fi
}

get_crypto_config() {
	local key=$(uci_get_by_name $1 key)
	local password=$(uci_get_by_name $1 password)
	if [ -n "$key" ]; then
		echo "\"key\": \"$key\","
	elif [ -n "$password" ]; then
		echo "\"password\": \"$password\","
	else
		logger -st $NAME -p3 "The password or key is not set."
	fi
}

gen_config_file() {
	local config_file=/var/etc/$NAME.$1.json
	cat <<-EOF >$config_file
		{
		    "server": "$(uci_get_by_name $1 server)",
		    "server_port": $(uci_get_by_name $1 server_port),
		    $(get_crypto_config $1)
		    "method": "$(uci_get_by_name $1 encrypt_method)",
		    "local_address": "0.0.0.0",$(get_plugin_config $1)
		    "timeout": $(uci_get_by_name $1 timeout 60),
		    "reuse_port": true
		}
EOF
	echo $config_file
}

start_rules() {
	config_load $NAME
	/usr/bin/ss-rules \
		-s "$(config_foreach get_server_ips servers)" \
		-l "$(uci_get_by_type transparent_proxy local_port 1234)" \
		-B "$(uci_get_by_type access_control wan_bp_list)" \
		-b "$(uci_get_by_type access_control wan_bp_ips)" \
		-W "$(uci_get_by_type access_control wan_fw_list)" \
		-w "$(uci_get_by_type access_control wan_fw_ips)" \
		-I "$(uci_get_by_type access_control lan_ifaces)" \
		-d "$(uci_get_by_type access_control lan_target)" \
		-a "$(config_foreach get_lan_hosts lan_hosts)" \
		-e "$(uci_get_by_type access_control ipt_ext)" \
		$(get_arg_out) $(get_arg_udp)
}

fw_reinit() {
	if [ "Z$?" = "Z0" -a "Z$(uci_get_by_type access_control wan_bp_list)" = "Z/dev/flag_gfwlist" ]; then
		[ $(ipset list gfwlist | wc -l) -lt 1 ] && /etc/init.d/dnsmasq-extra restart
		idx=$(($(iptables -t nat -L SS_SPEC_WAN_AC | grep all | sed -n -e '/ss_spec_dst_bp/=') +1))
		iptables -t nat    -I SS_SPEC_WAN_AC $idx -m set ! --match-set gfwlist dst -j RETURN 2>/dev/null \
			|| echo "# Transparent Proxy: TCP    NOT ENABLED"
		iptables -t mangle -I SS_SPEC_WAN_AC $idx -m set ! --match-set gfwlist dst -j RETURN 2>/dev/null \
			|| echo "# Transparent Proxy: UDP    NOT ENABLED"
	fi

	uci -q show firewall | sed -n 's/.*path=//p' | sed -n '/adbyby\|koolproxy\|dnsmasq/p' | tr -d \' | while read init; do
		sh $init restart >/dev/null 2>&1
	done
}

rules() {
	pidof ss-redir >/dev/null || return 0
	start_rules && fw_reinit || /usr/bin/ss-rules -f
}

start_redir() {
	validate_server $1 || return 0
	ss-redir -c $(gen_config_file $1) $2 $(get_arg_tfo $1) \
		-l $(uci_get_by_type transparent_proxy local_port 1234) \
		--mtu $(uci_get_by_type transparent_proxy mtu 1492) \
		-f /var/run/ss-redir$3-$1.pid
}

ss_redir() {
	command -v ss-redir >/dev/null 2>&1 || return 1
	local main_server=$(uci_get_by_type transparent_proxy main_server)
	has_valid_server $main_server || return 1
	local udp_relay_server=$(uci_get_by_type transparent_proxy udp_relay_server)

	rm -rf /var/dnsmasq.d/ss.conf
	for server in $main_server; do
		uci_get_by_name $server server | sed "s/^/server=\//;s/$/\/114.114.115.115/"    >> /var/dnsmasq.d/ss.conf
		uci_get_by_name $server server | sed "s/^/server=\//;s/$/\/208.67.222.222#443/" >> /var/dnsmasq.d/ss.conf
	done

	for server in $udp_relay_server; do
		uci_get_by_name $server server | sed "s/^/server=\//;s/$/\/114.114.115.115/"    >> /var/dnsmasq.d/ss.conf
		uci_get_by_name $server server | sed "s/^/server=\//;s/$/\/208.67.222.222#443/" >> /var/dnsmasq.d/ss.conf
	done

	( sort -u /var/dnsmasq.d/ss.conf  | sed '/\/\//d' > /var/dnsmasq.d/ss-servers.conf ) && rm -f /var/dnsmasq.d/ss.conf
	/etc/init.d/dnsmasq restart

	if [ "$udp_relay_server" = "same" ]; then
		for server in $main_server; do
			start_redir $server -u
		done
	else
		for server in $main_server; do
			start_redir $server
		done
		for server in $udp_relay_server; do
			start_redir $server -U -udp
		done
	fi
}

start_local() {
	validate_server $1 || return 0
	ss-local -c $(gen_config_file $1) -u $(get_arg_tfo $1) \
		-l $(uci_get_by_type socks5_proxy local_port 1080) \
		--mtu $(uci_get_by_type socks5_proxy mtu 1492) \
		-f /var/run/ss-local-$1.pid
}

ss_local() {
	command -v ss-local >/dev/null 2>&1 || return 0
	for server in $(uci_get_by_type socks5_proxy server); do
		start_local $server
	done
}

start_tunnel() {
	validate_server $1 || return 0
	ss-tunnel -c $(gen_config_file $1) -u \
		-l $(uci_get_by_type port_forward local_port 5300) \
		-L $(uci_get_by_type port_forward destination 8.8.4.4:53) \
		--mtu $(uci_get_by_type port_forward mtu 1492) \
		-f /var/run/ss-tunnel-$1.pid
}

ss_tunnel() {
	command -v ss-tunnel >/dev/null 2>&1 || return 0
	for server in $(uci_get_by_type port_forward server); do
		start_tunnel $server
	done
}

start() {
	mkdir -p /var/run /var/etc
	ss_redir && rules
	ss_local
	ss_tunnel
	has_valid_server $(uci_get_by_type transparent_proxy main_server) && add_cron
}

boot() {
	local delay=$(uci_get_by_type general startup_delay 0)
	(sleep $delay && start >/dev/null 2>&1) &
	return 0
}

kill_all() {
	kill -9 $(pidof $@) >/dev/null 2>&1
}

stop() {
	/usr/bin/ss-rules -f
	kill_all ss-redir ss-local ss-tunnel
	if [ -f /var/run/ss-plugin ]; then
		kill_all $(sort -u /var/run/ss-plugin)
		rm -f /var/run/ss-plugin
	fi
	rm -f /var/dnsmasq.d/ss.conf /var/dnsmasq.d/ss-servers.conf 2>/dev/null
	del_cron
}

add_cron() {
	sed -i '/shadowsocks_watchdog/d' $CRON_FILE
	echo '0   */3   * * *  rm -f /var/log/shadowsocks_watchdog.log 2>&1' >> $CRON_FILE
	echo '*    *    * * * /etc/init.d/shadowsocks watchdog >> /var/log/shadowsocks_watchdog.log 2>&1' >> $CRON_FILE
	/etc/init.d/cron restart
}

del_cron() {
	sed -i '/shadowsocks_watchdog/d' $CRON_FILE
	/etc/init.d/cron restart
}

watchdog(){
	command -v ss-redir >/dev/null 2>&1 || return 1
	local main_server=$(uci_get_by_type transparent_proxy main_server)
	has_valid_server $main_server || return 1

	LOGTIME=$(date "+%Y-%m-%d %H:%M:%S")
	TRPORT=$(uci_get_by_type transparent_proxy local_port 1234)
	GOOGLE=$(ping -4 accounts.gstatic.com -c 1 -w 5 2>/dev/null | sed '1{s/[^(]*(//;s/).*//;q}')
	IPINCN=119.29.29.29 #DNSPOD HTTPDNS

	if [ "Z$GOOGLE" = "Z" ]; then
		echo "[${LOGTIME}] Problem-DNS decteted, restarting ${NAME}..."
		[ -x /etc/init.d/dnsmasq-extra ] && /etc/init.d/dnsmasq-extra restart || /etc/init.d/dnsmasq restart
		stop  >/dev/null 2>&1
		start >/dev/null 2>&1
		return 0
	fi

	cat_connect(){
		url=$1
		# wget -> busybox wget
		( wget -qO- --tries=3 --timeout=4 $url >/dev/null 2>&1 ) ||
			( busybox wget -qO- -T10 $url >/dev/null 2>&1 )
	}

	iptables -t nat -I OUTPUT -p tcp -d $GOOGLE -j REDIRECT --to-port $TRPORT
	iptables -t nat -I OUTPUT -p tcp -d $IPINCN -j RETURN
	cat_connect $GOOGLE/generate_204
	if [ "Z$?" = "Z0" ]; then
		echo "[${LOGTIME}] ${NAME} No Problem."
	else
		cat_connect '119.29.29.29/d?dn=jd.com'
		if [ "Z$?" = "Z0" ]; then
			echo "[${LOGTIME}] Problem decteted, restarting ${NAME}..."
			[ -x /etc/init.d/haproxy-tcp ] && /etc/init.d/haproxy-tcp restart
			stop  >/dev/null 2>&1
			start >/dev/null 2>&1
		else
			echo '['$LOGTIME'] Network Problem. Do nothing.'
		fi
	fi

	iptables -t nat -D OUTPUT -p tcp -d $GOOGLE -j REDIRECT --to-port $TRPORT
	iptables -t nat -D OUTPUT -p tcp -d $IPINCN -j RETURN
	return 0
}
